from os import remove
from nicdaq import HallDAQ
import zeisscmm
import numpy as np
from time import time, sleep, perf_counter
from calibration import calib_data, remove_outliers, average_sample, filter_data

class HallProbe(HallDAQ):
    def __init__(self, coord_diff: str, rate: int, samps_per_chan: int, start_trigger=True, acquisition='finite'):
        '''
        HallProbe class inherits HallDAQ.
        coord_diff is the text file generated by Calypso which contain the
            rotation and translation values to switch between pcs and mcs
            reference frames.
        '''
        super().__init__(rate, samps_per_chan, start_trigger, acquisition)
        self.__load_coord_diff__(coord_diff)
        self.direction_index = {
            'xy': {'x': 1, 'y': 0},
            'yz': {'y': 2, 'z': 1},
            'zx': {'z': 0, 'x': 2}
        }
        self.scan_direction_v = {
            'x': 5 * self.rotation[0],
            'y': 5 * self.rotation[1],
            'z': 5 * self.rotation[2]
        }
        self.scan_length_index = {
            'x': 0,
            'y': 1,
            'z': 2
        }
        self.calib_coeffs = np.load('zg_calib_coeffs.npy')
        self.s_matrix = np.load('sensitivity.npy')
        self.probe_offset = np.genfromtxt('fsv_offset.txt')
        self.cmm = zeisscmm.CMM()
        self.sample_rate = self.__determine_sample_rate__()
        self.scan_speed = 5
    
    def __repr__(self):
        return 'Integrated Hall Probe Object'

    def __load_coord_diff__(self, diff_file):
        c_diff = np.genfromtxt(diff_file)
        self.rotation = c_diff[:9].reshape((3,3))
        self.translation = c_diff[9:]
        print(f'rotation: \n{self.rotation}')
        print(f'translation: \n{self.translation}')
    
    def __determine_sample_rate__(self):
        self.change_sampling(1, 10000)
        self.power_on()
        self.start_hallsensor_task()
        sleep(1)
        start = perf_counter()
        self.pulse()
        self.read_hallsensor()
        end = perf_counter()
        self.stop_hallsensor_task()
        self.power_off()
        sample_rate = self.SAMPLES_CHAN / (end - start)
        print(f'Sample Rate: {sample_rate}')
        return sample_rate
    
    def pcs2mcs(self, coordinate):
        return (coordinate - self.translation)@self.rotation + self.probe_offset

    def mcs2pcs(self, coordinate):
        return (coordinate - self.probe_offset)@np.linalg.inv(self.rotation) + self.translation

    def reduce_scan_density(self, scan_data: np.ndarray, scan_interval=0.5):
        '''
        scan_data is (n, 6) array (x, y, z, Bx, By, Bz)
        or
        (m, n, 6) array (m scan lines, n, samples per line, 6 columns)
        '''
        scan_distance = np.linalg.norm(scan_data[-1, :3] - scan_data[0, :3])
        pts_mm = scan_data.shape[0] / scan_distance
        interval_index = int(pts_mm / (1 / scan_interval))
        reduced_data = []
        for i in range(0, scan_data.shape[0], interval_index):
            reduced_data.append(scan_data[i])
        return np.array(reduced_data)

    def scan_point(self, *point):
        # print(type(point))
        # print(point.shape)
        if not point:
            point = self.mcs2pcs(self.cmm.get_position())
            self.power_on()
            self.start_hallsensor_task()
            sleep(1)
            self.pulse()
            data = self.read_hallsensor()
            cal_data = calib_data(self.calib_coeffs, data)
            self.power_off()
            self.stop_hallsensor_task()
            # Moved application of S matrix to mapping.py
            # Bxyz = self.s_matrix@average_sample(remove_outliers(cal_data))
            Bxyz = average_sample(remove_outliers(cal_data))
            # print(f'xyz: {point}\tBxyz: {Bxyz}')
            return np.hstack((point, Bxyz)).round(3)
        else:
            point = self.pcs2mcs(point[0])
            self.cmm.cnc_on()
            self.cmm.set_speed((40,40,40))
            self.cmm.goto_position(point)
            print('pre-while loop')
            while np.linalg.norm(point - self.cmm.get_position()) > 0.025:
                pass
            print('post-while loop')
            self.power_on()
            self.start_hallsensor_task()
            sleep(1)
            point = self.cmm.get_position()
            self.pulse()
            data = self.read_hallsensor()
            # print(f'raw point samples: {len(data)}')
            cal_data = calib_data(self.calib_coeffs, data)
            self.cmm.set_speed((70,70,70))
            self.cmm.cnc_off()
            self.power_off()
            self.stop_hallsensor_task()
            Bxyz = average_sample(remove_outliers(cal_data))
            # print(f'xyz: {point}\tBxyz: {Bxyz}')
            return np.hstack((point, Bxyz)).round(3)

    def scan_line(self, start_point, end_point, point_density):
        distance = np.linalg.norm(end_point - start_point)
        travel_time = distance / self.scan_speed
        samples = ((travel_time * self.sample_rate) - self.sample_rate).round(0).astype(int)
        # speed_direction_vector = 5 * np.abs((end_point - start_point) / np.linalg.norm((end_point - start_point)))
        speed_direction_vector = 5 * (end_point - start_point) / np.linalg.norm((end_point - start_point))
        print(f'speed vector: {speed_direction_vector}')
        self.change_sampling(1, samples)
        self.cmm.cnc_on()
        self.cmm.set_speed((20,20,20))
        # print(f'start pos: {start_point.shape}')
        # print(f'current pos: {self.cmm.get_position()}')
        self.cmm.goto_position(start_point)
        while np.linalg.norm(start_point - self.cmm.get_position()) > 0.025:
            pass
        # self.cmm.set_speed(speed_direction_vector)
        self.power_on()
        self.start_hallsensor_task()
        sleep(1)
        # self.cmm.goto_position(end_point)
        self.cmm.send(f'G01X{speed_direction_vector[0]:.6f}Y{speed_direction_vector[1]:.6f}Z{speed_direction_vector[2]:.6f}\r\n'.encode('ascii'))
        sleep(1)
        self.pulse()
        start_pt = self.cmm.get_position()
        data = self.read_hallsensor()
        end_pt = self.cmm.get_position()
        # while np.linalg.norm(end_point - self.cmm.get_position()) > 0.025:
        #     pass
        self.cmm.send('G01X0Y0Z0\r\n'.encode('ascii'))
        self.cmm.set_speed((70,70,70))
        self.cmm.cnc_off()
        self.stop_hallsensor_task()
        self.power_off()
        Bxyz = calib_data(self.calib_coeffs, data)
        linear = np.linspace(start_pt, end_pt, num=samples)
        if point_density == 'full res':
            return np.hstack((linear, Bxyz))
        else:
            filt_cutoff = 500
            for column in range(3):
                filt_column = filter_data(Bxyz[:, column], filt_cutoff)
                Bxyz[:, column] = filt_column
            filt_array = np.hstack((linear, Bxyz))
            filt_array = filt_array[filt_cutoff:-filt_cutoff]
            return self.reduce_scan_density(filt_array, scan_interval=point_density)

    def scan_area(self, start_array, allocated_array, pt_density, num_samples, scan_direction):
        filt_cutoff = 500
        filt_allocated_array = allocated_array[:, filt_cutoff:-filt_cutoff, :]
        print(f'alloc array: {allocated_array.shape}')
        print(f'filt alloc: {filt_allocated_array.shape}')
        self.change_sampling(1, num_samples)
        self.cmm.cnc_on()
        self.cmm.set_speed((20,20,20))
        self.power_on()
        for i, point in enumerate(start_array):
            self.cmm.goto_position(point)
            while np.linalg.norm(point - self.cmm.get_position()) > 0.025:
                pass
            self.start_hallsensor_task()
            sleep(1)
            self.cmm.send(f'G01X{self.scan_direction_v[scan_direction][0]:.6f}Y{self.scan_direction_v[scan_direction][1]:.6f}Z{self.scan_direction_v[scan_direction][2]:.6f}\r\n'.encode('ascii'))
            sleep(1)
            self.pulse()
            start_pt = self.cmm.get_position()
            data = self.read_hallsensor()
            end_pt = self.cmm.get_position()
            self.stop_hallsensor_task()
            Bxyz = calib_data(self.calib_coeffs, data)
            linear = np.linspace(start_pt, end_pt, num=num_samples)
            for column in range(3):
                filt_column = filter_data(Bxyz[:, column], filt_cutoff)
                Bxyz[:, column] = filt_column
            filt_array = np.hstack((linear, Bxyz))
            filt_array = filt_array[filt_cutoff:-filt_cutoff]
            filt_allocated_array[i] = filt_array
        self.cmm.send('G01X0Y0Z0\r\n'.encode('ascii'))
        self.cmm.set_speed((70,70,70))
        self.cmm.cnc_off()
        self.power_off()
        reduced_array_list = []
        for line in filt_allocated_array:
            reduced_array_list.append(self.reduce_scan_density(line, scan_interval=pt_density))
        return (np.array(reduced_array_list), filt_allocated_array)


    def scan_volume(self, start_point, scan_distance, pt_density, scan_plane, scan_direction):
        pass

    def create_scan_plane(self, start_point, scan_distance, pt_density, scan_plane, scan_direction):
        points = np.arange(0, scan_distance[self.direction_index[scan_plane][scan_direction]]+pt_density, pt_density)
        points_array = np.array([start_point]*points.shape[0])
        points_array[:, self.direction_index[scan_plane][scan_direction]] = points + start_point[self.direction_index[scan_plane][scan_direction]]
        return points_array

    def shutdown(self):
        self.cmm.close()
        self.close_tasks()
        self.power_off()
        

if __name__ == '__main__':
    start_points_y = np.arange(-10, 55.5, 0.5)
    start_xyz = np.zeros((start_points_y.shape[0], 3))
    for i, pt in enumerate(start_points_y):
        start_xyz[i] = -25, pt, 10
    test = HallProbe(r'D:\CMM Programs\Hallprobe Test Magnet\magnet_alignment.txt', 1, 2)
    empty_np = np.zeros((1,1,6))
    for start_pt in start_xyz:
        data = test.scan_line(test.pcs2mcs(start_pt), test.pcs2mcs(start_pt + np.array([75, 0, 0])), 0.5)
        for i, pt in enumerate(data):
            data[i, :3] = test.mcs2pcs(pt[:3])
            data[i, 3:] = pt[3:]@np.linalg.inv(test.rotation)
        reduced_data = test.reduce_scan_density(data)
        with open('fieldmap_ring.txt', 'a') as file:
            np.savetxt(file, reduced_data, fmt='%.6f')
    test.shutdown()