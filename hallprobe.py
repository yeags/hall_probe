from os import remove
from nicdaq import HallDAQ
import zeisscmm
import numpy as np
from time import time, sleep, perf_counter
from calibration import calib_data, remove_outliers, average_sample

class HallProbe(HallDAQ):
    def __init__(self, coord_diff: str, rate: int, samps_per_chan: int, start_trigger=True, acquisition='finite'):
        '''
        HallProbe class inherits HallDAQ.
        coord_diff is the text file generated by Calypso which contain the
            rotation and translation values to switch between pcs and mcs
            reference frames.
        '''
        super().__init__(rate, samps_per_chan, start_trigger, acquisition)
        self.__load_coord_diff__(coord_diff)
        self.calib_coeffs = np.load('zg_calib_coeffs.npy')
        self.s_matrix = np.load('sensitivity.npy')
        self.probe_offset = np.genfromtxt('fsv_offset.txt')
        self.cmm = zeisscmm.CMM()
        self.sample_rate = self.__determine_sample_rate__()
        self.scan_speed = 5
    
    def __repr__(self):
        return 'Integrated Hall Probe Object'

    def __load_coord_diff__(self, diff_file):
        c_diff = np.genfromtxt(diff_file)
        self.rotation = c_diff[:9].reshape((3,3))
        self.translation = c_diff[9:]
    
    def __determine_sample_rate__(self):
        self.change_sampling(1, 10000)
        self.power_on()
        self.start_hallsensor_task()
        sleep(1)
        start = perf_counter()
        self.pulse()
        self.read_hallsensor()
        end = perf_counter()
        self.stop_hallsensor_task()
        self.power_off()
        sample_rate = self.SAMPLES_CHAN / (end - start)
        print(f'Sample Rate: {sample_rate}')
        return sample_rate
    
    def pcs2mcs(self, coordinate):
        return (coordinate - self.translation)@self.rotation + self.probe_offset

    def mcs2pcs(self, coordinate):
        return (coordinate - self.probe_offset)@np.linalg.inv(self.rotation) + self.translation

    def reduce_scan_density(self, scan_data: np.ndarray, scan_interval=0.5):
        '''
        scan_data is (n, 6) array (x, y, z, Bx, By, Bz)
        '''
        scan_distance = np.linalg.norm(scan_data[-1, :3] - scan_data[0, :3])
        pts_mm = scan_data.shape[0] / scan_distance
        interval_index = int(pts_mm / (1 / scan_interval))
        reduced_data = []
        for i in range(0, scan_data.shape[0], interval_index):
            reduced_data.append(scan_data[i])
        return np.array(reduced_data)

    def scan_point(self, *point):
        if not point:
            point = self.cmm.get_position()
            self.power_on()
            self.start_hallsensor_task()
            sleep(1)
            self.pulse()
            data = self.read_hallsensor()
            cal_data = calib_data(self.calib_coeffs, data)
            self.power_off()
            self.stop_hallsensor_task()
            Bxyz = self.s_matrix@average_sample(remove_outliers(cal_data))
            return np.hstack((point, Bxyz))
        else:
            point = point[0]
            self.cmm.cnc_on()
            self.cmm.set_speed((40,40,40))
            self.cmm.goto_position(point)
            while np.linalg.norm(point - self.cmm.get_position()) > 0.025:
                pass
            self.power_on()
            self.start_hallsensor_task()
            sleep(1)
            point = self.cmm.get_position()
            self.pulse()
            data = self.read_hallsensor()
            cal_data = calib_data(self.calib_coeffs, data)
            self.cmm.set_speed((70,70,70))
            self.cmm.cnc_off()
            self.power_off()
            self.stop_hallsensor_task()
            Bxyz = self.s_matrix@average_sample(remove_outliers(cal_data))
            return np.hstack((point, Bxyz))

    def scan_line(self, start_point, end_point, point_density):
        distance = np.linalg.norm(end_point - start_point)
        travel_time = distance / self.scan_speed
        samples = ((travel_time * self.sample_rate) - self.sample_rate).round(0).astype(int)
        speed_direction_vector = 5 * np.abs((end_point - start_point) / np.linalg.norm((end_point - start_point)))
        self.change_sampling(1, samples)
        self.cmm.cnc_on()
        self.cmm.set_speed((20,20,20))
        self.cmm.goto_position(start_point)
        while np.linalg.norm(start_point - self.cmm.get_position()) > 0.025:
            pass
        self.cmm.set_speed(speed_direction_vector)
        self.power_on()
        self.start_hallsensor_task()
        sleep(1)
        self.cmm.goto_position(end_point)
        sleep(1)
        self.pulse()
        start_pt = self.cmm.get_position()
        data = self.read_hallsensor()
        end_pt = self.cmm.get_position()
        while np.linalg.norm(end_point - self.cmm.get_position()) > 0.025:
            pass
        self.cmm.set_speed((70,70,70))
        self.cmm.cnc_off()
        self.stop_hallsensor_task()
        self.power_off()
        Bxyz = calib_data(self.calib_coeffs, data)
        for i, sample in enumerate(Bxyz):
            Bxyz[i] = self.s_matrix@sample
        linear = np.linspace(start_pt, end_pt, num=samples)
        if point_density == 'full res':
            return np.hstack((linear, Bxyz))
        else:
            return self.reduce_scan_density(np.hstack((linear, Bxyz)), scan_interval=point_density)

    def scan_area_volume(self, start_point, scan_distance, grid=0.5, scan_plane='xy'):
        pass

    def shutdown(self):
        self.cmm.close()
        self.close_tasks()
        self.power_off()
        

if __name__ == '__main__':
    start_points_y = np.arange(-10, 55, 0.5)
    start_xyz = np.zeros((start_points_y.shape[0], 3))
    for i, pt in enumerate(start_points_y):
        start_xyz[i] = -25, pt, 3
    test = HallProbe(r'D:\CMM Programs\Hallprobe Test Magnet\magnet_alignment.txt', 1, 2)
    for start_pt in start_xyz:
        data = test.scan_line(test.pcs2mcs(start_pt), test.pcs2mcs(start_pt + np.array([75, 0, 0])))
        xyz = data[0]
        Bxyz = data[1]
        for i, pt in enumerate(xyz):
            xyz[i] = test.mcs2pcs(pt)
        for i, pt in enumerate(Bxyz):
            Bxyz[i] = pt@np.linalg.inv(test.rotation)
        h_stack = np.hstack((xyz, Bxyz))
        reduced_data = test.reduce_scan_density(h_stack)
        with open('fieldmap_reduced.txt', 'a') as file:
            np.savetxt(file, reduced_data, fmt='%.6f')
        # np.save('xyz.npy', xyz, allow_pickle=False)
        # np.save('Bxyz.npy', Bxyz, allow_pickle=False)
    test.shutdown()